<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https:&#x2F;&#x2F;pranabekka.github.io/style.css">
  <link rel="icon" href="https:&#x2F;&#x2F;pranabekka.github.io/favicon.svg?v=2">
  <link rel="me" href="https://mastodon.social/@pranabekka">
  <link type="application/atom+xml" rel="alternate" href="https:&#x2F;&#x2F;pranabekka.github.io/atom.xml" title="Pranab&#x27;s site">
  <title>
Significant Whitespace Lisp Syntax
 - Pranabâ€™s site

</title>
</head>

<body>
  <main>
      

<h1>Significant Whitespace Lisp Syntax
</h1>


<p class="subtitle">
  On
  <img src="/favicon.svg" id="icon">
  <a href=https:&#x2F;&#x2F;pranabekka.github.io>
    Pranabâ€™s site

  </a>
</p>

<p class="subtitle">
  
    Jul 11, 2023
    
    (IST)
  
</p>



  <details class="contents">
    <summary>Show/Hide contents</summary>
    <ol>
    
      <li>
        <a href="https://pranabekka.github.io/whitespace-lisp-syntax/#function-calls">Function Calls</a>
        
      </li>
    
      <li>
        <a href="https://pranabekka.github.io/whitespace-lisp-syntax/#sub-expressions-blocks-functions-as-arguments">Sub-Expressions&#x2F;Blocks (Functions as Arguments)</a>
        
      </li>
    
      <li>
        <a href="https://pranabekka.github.io/whitespace-lisp-syntax/#inline-syntax">Inline Syntax</a>
        
      </li>
    
      <li>
        <a href="https://pranabekka.github.io/whitespace-lisp-syntax/#sugar-for-list-of-lists">Sugar: [] (for List of Lists)</a>
        
      </li>
    
      <li>
        <a href="https://pranabekka.github.io/whitespace-lisp-syntax/#splitting-arguments-across-lines">Splitting Arguments Across Lines</a>
        
      </li>
    
      <li>
        <a href="https://pranabekka.github.io/whitespace-lisp-syntax/#infix-syntax">Infix Syntax</a>
        
          <ol>
            
              <li>
                <a href="https://pranabekka.github.io/whitespace-lisp-syntax/#math">Math</a>
              </li>
            
              <li>
                <a href="https://pranabekka.github.io/whitespace-lisp-syntax/#comparison">Comparison</a>
              </li>
            
          </ol>
        
      </li>
    
      <li>
        <a href="https://pranabekka.github.io/whitespace-lisp-syntax/#benefits-over-other-significant-whitespace-syntaxes">Benefits Over Other Significant Whitespace Syntaxes</a>
        
      </li>
    
      <li>
        <a href="https://pranabekka.github.io/whitespace-lisp-syntax/#conclusion">Conclusion</a>
        
      </li>
    
    </ol>
  </details>

<hr>

<p>I was browsing the web when I came upon
the Rhombus language by the Racket team,
and I couldnâ€™t help but have
a few thoughts of my own for a Lisp syntax
with significant whitespace.
The key difference in my idea
is that it works quite transparently with s-expressions,
and has some extra sugar and rules
to help with parentheses elision.</p>
<p>NOTE: Some knowledge of Lisp is assumed.</p>
<p>NOTE: Elision (removal) rules only mean that there are ways
for the computer to infer the position of parentheses.
You can still use parentheses, as demonstrated later.</p>
<h2 id="function-calls">Function Calls<a class="zola-anchor" href="#function-calls" aria-label="Anchor link for: function-calls">ğŸ”—</a></h2>
<p>The first word (symbol) in a line is a function call,
and the rest are arguments, subject to variable expansion.
This is an example of parentheses elision:
you can elide (remove) the parentheses,
since their position is inferred
at the beginning and end of a line
(not quite, see next point).</p>
<pre class="z-code"><code><span class="z-text z-plain">my-func arg1 arg2

; turns into:

(my-func arg1 arg2)
</span></code></pre>
<h2 id="sub-expressions-blocks-functions-as-arguments">Sub-Expressions/Blocks (Functions as Arguments)<a class="zola-anchor" href="#sub-expressions-blocks-functions-as-arguments" aria-label="Anchor link for: sub-expressions-blocks-functions-as-arguments">ğŸ”—</a></h2>
<p>An indented line starts a sub-expression
in the form immediately above it in the â€œindentation hierarchyâ€.
So the automatic placement of parentheses
is slightly more complicated â€”
if the next line (expression) is indented,
then the closing parenthesis is held off
until a line with less indentation is encountered
(or the end of the file).</p>
<pre class="z-code"><code><span class="z-text z-plain">fun1 arg-x
  fun2 arg-n

; turns into

(fun1 arg-x
  (fun2 arg-n))
</span></code></pre>
<pre class="z-code"><code><span class="z-text z-plain">fun3
  fun4
  fun5

; turns into

(fun3 (fun4) (fun5))
</span></code></pre>
<h2 id="inline-syntax">Inline Syntax<a class="zola-anchor" href="#inline-syntax" aria-label="Anchor link for: inline-syntax">ğŸ”—</a></h2>
<p>The above rules with significant whitespace
might also be called â€œblock syntaxâ€,
since it necessarily requires blocks
that span both dimensions.
The parentheses syntax may also be called â€œinline syntaxâ€,
since it can be written in a single line
without changing the meaning
(although it severely impacts readability).</p>
<p>The two syntaxes can be mixed together
to create more complicated forms.</p>
<pre class="z-code"><code><span class="z-text z-plain">let (
    variable value
  )
  my-fun variable

; turns into

(let (
    (variable value)
  )
  (my-fun variable))

; which is the same as

(let ((variable value))
  (my-fun variable))
</span></code></pre>
<p>(You need not write it as shown above.)</p>
<p>The following also achieves the same thing:</p>
<pre class="z-code"><code><span class="z-text z-plain">let (
    variable value )
  my-fun variable
</span></code></pre>
<h2 id="sugar-for-list-of-lists">Sugar: <code>[]</code> (for List of Lists)<a class="zola-anchor" href="#sugar-for-list-of-lists" aria-label="Anchor link for: sugar-for-list-of-lists">ğŸ”—</a></h2>
<p>To help create a list of lists,
there will also be a <code>[]</code> reader macro
(used like a function)
that wraps its arguments into a list.</p>
<pre class="z-code"><code><span class="z-text z-plain">let
  []
    variable value
  my-fun variable

; turns into:

(let
  (
    (variable value))
  (my-fun variable))

; which is the same as:

(let ((variable value))
  (my-fun variable))
</span></code></pre>
<p>Hereâ€™s another example with a lambda.</p>
<pre class="z-code"><code><span class="z-text z-plain">[]
  lambda (x)
    func x
  arg1

; turns into:

(
  (lambda (x)
    (func x))
  arg1)

; which is the same as:

((lambda (x) (func x)) arg1)
</span></code></pre>
<h2 id="splitting-arguments-across-lines">Splitting Arguments Across Lines<a class="zola-anchor" href="#splitting-arguments-across-lines" aria-label="Anchor link for: splitting-arguments-across-lines">ğŸ”—</a></h2>
<p>If you must split arguments into multiple lines,
a â€œspliceâ€ (reader) macro is available.
(Another name might be more suitable,
given the pre-existing splice macro
â€” in Common Lisp, at least.)</p>
<pre class="z-code"><code><span class="z-text z-plain">my-func arg1 arg2 arg3
      @ arg4 arg5 arg6

; is equivalent to

(my-func arg1 arg2 arg3
         arg4 arg5 arg6)
</span></code></pre>
<p>Without the â€œspliceâ€ macro
it would try to call <code>arg4</code> as a function
with the arguments <code>arg5</code> and <code>arg6</code>.</p>
<!--
You can also mix up the `[]` and `@` macros.

```
[]
  @ item1 item2 item3
  @ item4 item5 item6

; turns into

(item1 item2 item3
 item4 item5 item6)
```
-->
<h2 id="infix-syntax">Infix Syntax<a class="zola-anchor" href="#infix-syntax" aria-label="Anchor link for: infix-syntax">ğŸ”—</a></h2>
<p>While this goes a long way towards
making lisp more palatable for some people,
(maybe even appealing)
there are two places where
programmers from other languages expect infix syntax.</p>
<h3 id="math">Math<a class="zola-anchor" href="#math" aria-label="Anchor link for: math">ğŸ”—</a></h3>
<p>The first place infix syntax is often used is for (simple) math,
for which the <code>$</code> macro is provided.
The <code>$</code> symbol was chosen because
it is used for indicating math in markup languages
like LaTeX, Typst, and Kramdown
(a feature-ful flavour of markdown).</p>
<pre class="z-code"><code><span class="z-text z-plain">$ 1 + 2 + var / 7

; turns into:

(+ 1 2 (/ var 7))
</span></code></pre>
<h3 id="comparison">Comparison<a class="zola-anchor" href="#comparison" aria-label="Anchor link for: comparison">ğŸ”—</a></h3>
<p>The second place where other languages use infix syntax
is for comparisons in conditionals and loops.
The <code>check</code> or <code>?</code> macro can be used for this.</p>
<pre class="z-code"><code><span class="z-text z-plain">? my-var != your-var

; turns into:

(? my-var != your-var)

; which is the same as:

(not (eq my-var your-var))
</span></code></pre>
<p>Maybe infix math could also be allowed here?
â€” just to make things easier
for the kinds of people this syntax might appeal to.</p>
<h2 id="benefits-over-other-significant-whitespace-syntaxes">Benefits Over Other Significant Whitespace Syntaxes<a class="zola-anchor" href="#benefits-over-other-significant-whitespace-syntaxes" aria-label="Anchor link for: benefits-over-other-significant-whitespace-syntaxes">ğŸ”—</a></h2>
<p>This syntax might even be more appealing to some people
over other syntaxes with significant whitespace
for several reasons.</p>
<ul>
<li>Only spaces to separate arguments.</li>
<li>Only spaces to separate function from arguments</li>
<li>No colon for indented blocks</li>
<li>Consistent syntax (for both block and inline)</li>
</ul>
<p>Getting rid of commas means that
you no longer need to balance them.
Lots of recent languages have taken to
allowing trailing commas just to deal with that issue.
Having no commas makes it easier to move things around.
Furthermore, commas repeated the work
that spaces were already doing.
If whitespace is significant,
then you might as well lean into it.
Signifcant whitespace ++.</p>
<p>All languages (that I know of)
treat the first word as a (special) function call,
and the rest are just keywords or arguments
for that function call,
so the surrounding parentheses for the arguments
are largely unecessary.
The command-line does this beautifully.
We have now rid ourselves of all the superfluous parentheses
(that a host of other languages also have, might I add),
and made whitespace even more significant.</p>
<p>In Python, a colon is required at the end of some forms
like <code>if</code>, <code>else</code>, and <code>for</code>.
This is despite the fact that
the content of these forms is already indented.
So the colon is repeating work
that is already being achieved by indentation.
Furthermore, having tried some Python,
I know for a fact that I would get
annoying syntax errors for missing a colon in various forms.</p>
<p>This syntax also has very simple and consistent rules,
such that even if they are not explicitly mentioned,
a user should get a grasp of them
much sooner than other languages
that have special forms and exceptions of all kinds.
Essentially all language features reduce to
â€œfunctionsâ€ and lists describing various things.
(I say â€œfunctionsâ€ in quotes,
because there are special functions and macros as well.)
Only Lisp syntax is simpler and more consistent.</p>
<h2 id="conclusion">Conclusion<a class="zola-anchor" href="#conclusion" aria-label="Anchor link for: conclusion">ğŸ”—</a></h2>
<p>We have a syntax with (even more!) significant whitespace,
consistent rules, infix syntax and easy inline syntax,
that should be more palatable to users of other languages,
and easy for existing Lispers to learn and share.
It might even reduce strain on Lispersâ€™ pinkies.</p>











  </main>
  <footer>
    <nav>
      <a href="https:&#x2F;&#x2F;pranabekka.github.io/about#contact">Feedback</a>
      <a href="https:&#x2F;&#x2F;pranabekka.github.io">Home</a>
      <a href="#">Go to top â†‘</a>
      
<a href="https://github.com/pranabekka/pranabekka.github.io/blob/main/content&#x2F;whitespace-lisp-syntax.md">
  Page source
</a>

    </nav>
  </footer>
</body>

</html>
